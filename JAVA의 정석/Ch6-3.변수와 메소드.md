# 3. 변수와 메서드

## 3.1 선언 위치에 따른 변수의 종류

 변수는 클래스 변수, 인스턴스 변수, 지역 변수 세 종류가 있다. 변수의 종류를 결정지는 중요한 요소는 변수의 선언 위치이므로 변수의 종류를 파악하기 위해서는 변수가 어느 영역에 선언되었는지를 확인하는 것이 중요하다. 멤버 변수를 제외한 나머지 변수들은 모두 지역변수이고, 멤버 변수 중 static이 붙은 변수가 클래스 변수, 붙지 않은 변수가 인스턴스 변수이다.



|  변수의 종류  |             선언위치             |      메모리에 생성시기      |
| :-----------: | :------------------------------: | :-------------------------: |
|  클래스 변수  |           클래스 영역            | 클래스가 메모리에 올라갈 때 |
| 인스턴스 변수 |           클래스 영역            |    인스턴스가 생성될 때     |
|   지역 변수   | 메소드, 생성자, 초기화 블럭 내부 |   변수 선언문이 수행될 때   |



1. 인스턴스 변수

    클래스 영역에 선언되며, 클래스의 인스턴스를 생성할 때 만들어진다. 그렇기 때문에 인스턴스 변수를 사용하기 위해서는 먼저 인스턴스를 생성해야 한다. 인스턴스는 독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 있다. 인스턴스마다 고유한 상태를 유지해야하는 속성의 경우, 인스턴스 변수로 선언한다.

   

2. 클래스 변수

    클래스 변수를 선언하는 방법은 인스턴스 변수 앞에 static을 붙이기만 하면 된다. 인스턴스 변수와 달리 클래스 변수는 모든 인스턴스가 공통된 저장공간을 공유하게 된다. 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야 하는 속성의 경우, 클래스 변수로 선언해야 한다.

    클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다. `클래스이름.클래스변수`와 같은 형식으로 사용한다. 클래스 변수는 클래스가 메모리에 로딩될 때 생성되어 프로그램이 종료될 때까지 유지되며, public을 붙이면 같은 프로그램 내에서 어디서나 접근할 수 있는 전역변수(global variable)의 성격을 갖는다.

   

3. 지역 변수

    메소드 내에 선언되어 매소드 내에서만 사용 가능하며 메소드가 종료되면 메모리에서 소멸되어 사용할 수 없게 된다.



## 3.2 클래스 변수와 인스턴스 변수

 인스턴스 변수는 인스턴스가 생성될 때마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만, 클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로 항상 공통된 값을 가진다. 클래스 변수를 사용할 때는 `클래스이름.클래스변수` 형태로 사용한다.



## 3.3 메소드

 메소드는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것이다. 기본적으로 수학 함수와 유사하며, 어떤 값을 입력하면 작업을 수행해서 결과를 반환한다. 그저 메소드가 작업을 수행하는데 필요한 값만 넣고 원하는 결과를 얻으면 될 뿐, 내부적으로 어떤 과정을 거쳐 결과를 만들어내는지 몰라도 된다. 그래서 메소드를 내부가 보이지 않는 **블랙박스**라고도 한다.



### 메소드를 사용하는 이유

1. 높은 재사용성(reusability)

    Java API에서 제공하는 메소드들을 사용하는 것처럼 한번 만들어 놓은 메소드는 여러 번 사용할 수 있으며 다른 프로그램에서도 사용 가능하다.

   

2. 중복된 코드의 제거

    프로그램 작성시 같은 내용의 문장들이 여러 곳에 반복해서 나타나곤 한다. 이렇게 반복되는 문장을 하나로 묶어서 메소드로 작성해 놓으면, 메소드를 호출하는 문장 하나로 대체할 수 있고 관리와 수정이 용이해진다.

   

3. 프로그램의 구조화

    큰 규모의 프로그램에서는 문장들을 작업 단위로 나눠서 여러 개의 메소드에 담아 프로그램의 구조를 단순화시키는 것이 필수적이다. main 메소드는 프로그램의 전체 흐름이 한 눈에 들어올 정도로 단순하게 구조화하는 것이 좋다. 

   

## 3.4 메소드의 선언과 구현

 메소드는 크게 두 부분, 선언부(header)와 구현부(body)로 이루어져 있다.

```
반환타입 메소드이름 (타입 매개변수명1, 타입 매개변수명2, ... ) // 선언부
{
	// 구현부, 수행 코드
}
```



### 메소드 선언부(method declaration, method header)

 메소드 선언부는 메소드의 이름, 매개변수 선언, 반환타입으로 구성되어 있다. 메소드가 작업을 수행하기 위해 어떤 값들을 필요로 하고 작업의 결과로 어떤 타입의 값을 반환하는지에 대한 정보를 제공한다.

 메소드의 선언부는 후에 변경사항이 발생하지 않도록 신중히 작성해야 한다. 메소드의 선언부를 변경하게 되면, 그 메소드가 호출되는 모든 곳도 같이 변경해야 하기 때문이다.



### 매개변수 선언(parameter declaration)

 매개변수는 메소드가 작업을 수행하는데 필요한 값들을 제공받기 위한 것이다. 한 가지 주의할 점은 일반적인 변수 선언과 달리 두 변수의 타입이 같아도 변수의 타입을 생략할 수 없다는 것이다. 매개변수의 개수는 거의 제한이 없지만 너무 많을 경우, 배열이나 참조변수를 사용하면 된다.



### 메소드의 이름

 메소드의 이름도 변수의 명명규칙대로 작성하면 된다. 메소드는 특정 작업을 수행하므로 이름이 **동사**인 경우가 많으며, 이름만으로도 메소드의 기능을 쉽게 알 수 있도록 함축적이면서도 의미있는 이름을 짓도록 해야한다.



### 반환타입

 메소드의 작업 수행 결과인 반환값의 타입을 적는다. 반환값이 없는 경우 `void`를 적으면 된다.



### 지역변수

 메소드 내에 선언된 변수들은 그 메소드 내에서만 사용할 수 있으므로 서로 다른 메소드라면 같은 이름의 변수를 선언해도 된다. 메소드 내의 선언된 변수를 지역변수라고 한다.



## 3.5 메소드의 호출

 `메소드이름(값1, 값2, ... );`



### 인자(argument)와 매개변수(parameter)

 메소드 호출시 괄호 () 안에 지정해준 값들을 인자 또는 인수라고 한다. 인자의 개수와 순서는 호출된 메소드에 선언된 매개변수와 일치해야 한다. 인자는 메소드가 호출되면서 매개변수에 대입되므로, 인자의 타입은 매개변수의 타입과 일치하거나 자동 형변환이 가능한 것이어야 한다.



### 메소드의 실행 흐름

 같은 클래스 내의 메소드끼리는 참조변수를 사용하지 않아도 서로 호출이 가능하지만 static 메소드는 같은 클래스 내의 인스턴스 메소드를 호출할 수 없다.(이유는 뒤에 3.11, 3.12 나옴)

 메소드가 호출되면 지금까지 실행 중이던 메소드는 실행을 잠시 멈추고 호출된 메소드의 문장들이 실행된다. 호출된 메소드의 작업이 모두 끝나면, 다시 호출한 메소드로 돌아와 이후의 문장들을 실행한다.



## 3.6 return 문

 return 문은 현재 실행중인 메소드를 종료하고 호출한 메소드로 돌아간다. 반환값의 유무에 관계없이 모든 메소드에는 적어도 하나의 return 문이 있어야 한다. 그런데도 반환값이 void인 경우, return 문 없이도 아무런 문제가 없었던 이유는 컴파일러가 메소드의 마지막에 `return ;` 을 자동적으로 추가해주었기 때문이다.

 return 문의 반환값으로 주로 변수가 오긴 하지만 경우에 따라 수식이 올 수 있다. 수식이 오면 수식의 결과값을 반환한다.



### 매개변수의 유효성 검사

 메소드를 작성할 때 제일 먼저 매개변수의 값이 적절한 것인지 확인해야한다. 호출하는 쪽에서 적절한 인자를 넘겨주겠지라는 생각은 절대로 가져서는 안된다. 타입만 맞으면 어떤 값도 매개변수를 통해 넘어올 수 있기 때문에, 가능한 모든 경우의 수에 고민하고 그에 대비한 코드를 작성해야 한다. 적절하지 않은 값이 넘어온다면 내부에서 값을 보정하거나 그렇지 않으면 return 문을 사용해 작업을 중단한다.

## 3.7 JVM의 메모리 구조

 응용 프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받는다. JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.



### 3가지 주요 영역

1. method area

    프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 .class 파일을 읽어서 분석하여 클래스에 대한 정보를 저장하는 영역, 클래스 변수도 이 영역에서 생성되고 저장된다.

2. Heap

    인스턴스가 생성되는 공간, 인스턴스 변수들이 생성되는 공간.

3. 호출 스택(Call Stack, Execution Stack)

    메소드의 작업에 필요한 메모리 공간을 제공한다. 이 메모리는 메소드가 작업을 수행하는 동안 생성되는 지역변수, 매개변수들과 연산의 중간결과 등을 저장하는데 사용된다. 메소드가 종료되면 메모리 공간은 반환되어 비워진다. 호출스택의 제일 상위에 위치하는 메소드가 현재 실행 중인 메소드이며 나머지는 대기상태에 있게 된다. 바로 아래있는 메소드가 바로 위 메소드를 호출한 메소드이다.



## 3.8 기본형 매개변수와 참조형 매개변수

 자바에서는 메소드를 호출할 때 매개변수(Parameter)로 지정한 값을 메소드의 매개변수에 복사해 넘겨준다. 기본형일 때는 기본형 값이 복사되지만 참조형이면 인스턴스의 주소가 복사된다.

 메소드의 매개변수를 기본형으로 선언하면 복사된 값을 얻지만 참조형으로 선언하면 값이 저장된 곳의 주소를 알 수 있기 때문에 값을 읽어 오는 것은 물론 값을 변경하는 것도 가능하다.



## 3.9 참조형 반환타입

 매개변수뿐만 아니라 반환타입도 참조형이 될 수 있다. 



## 3.10 재귀호출(Recursive Call)

 메소드 내부에서 메소드 자기 자신을 다시 호출하는 것을 재귀호출이라 한다. 코드가 오로지 재귀호출뿐이면, 무한 반복에 빠지게 된다. 이를 막기 위해 재귀호출도 조건문이 필수적으로 따라다닌다.

 그럼 재귀호출도 반복하는 과정인데 왜 반복문 대신 재귀호출을 사용할까? 그 이유는 재귀호출이 주는 논리적 간결함 때문이다. 보다 단순한 구조로 알아보기 쉽게 작성되어지므로 논리적 오류가 발생할 확률도 줄어들고 나중에 수정하기도 좋다.

  어떤 작업을 반복적으로 처리해야한다면, 먼저 반복문으로 작성해보고 너무 복잡하면 재귀호출로 간단하게 할 수 없는지 고민해볼 필요가 있다. 재귀호출은 비효율적이므로 재귀호출에 드는 비용보다 재귀호출의 간결함이 주는 이득이 충분히 큰 경우에만 사용해야 한다.



## 3.11 클래스 메소드와 인스턴스 메소드

 메소드 앞에 static이 붙어 있으면 클래스 메소드이고 붙어 있지 않으면 인스턴스 메소드이다.  클래스 메소드도 클래스 변수처럼 객체를 생성하지 않고도 `클래스 이름.메소드이름()` 와 같은 식으로 호출이 가능하다. 반면에 인스턴스 메소드는 반드시 객체를 생성해야만 호출할 수 있다.

 그러면 어느 경우에 static을 사용해서 클래스 메소드로 정의해야 하는걸까?, 클래스는 변수와 변수에 관련된 메소드의 집합이므로, 같은 클래스 내에 있는 변수와 메소드는 밀접한 관계가 있다. 이 메소드 중에서 인스턴스와 관련없는(인스턴스 변수나 인스턴스 메소드를 사용하지 않는) 메소드를 클래스 메소드로 정의한다.

 물론 인스턴스 변수, 메소드를 사용하지 않는다고 해서 반드시 클래스 메소드로 정의해야하는 것은 아니지만 특별한 이유가 없는 한 그렇게 하는 것이 일반적이다.



1. 클래스를 설계할 때, 멤버 변수 중 모든 인스턴스에 공통으로 사용하는 변수에 static을 붙인다.

    각 인스턴스는 서로 독립적이기 때문에 서로 다른 값을 유지한다. 그러나 모든 인스턴스에서 같은 값으로 유지되어야 하는 변수는 static을 붙여서 클래스 변수로 정의해야 한다.

   

2. 클래스 변수(static 변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.

    static이 붙은 변수는 클래스가 메모리에 올라갈 때 생성되기 때문이다.

   

3. 클래스 메소드는 인스턴스 변수를 사용할 수 없다.

    인스턴스 변수는 인스턴스가 반드시 존재해야만 사용할 수 있는데, 클래스 메소드는 인스턴스 생성하지 않아도 호출 가능하므로 클래스 메소드가 호출되었을 때 인스턴스가 존재하지 않을 수 있다. 그래서 클래스 메소드에서 인스턴스 변수의 사용을 금지한다.

    반면에 인스턴스 변수나 인스턴스 메소드에서는 static 변수를 사용하는 것이 언제나 가능하다. 인스턴스 변수가 존재한다는 것은 static 변수가 이미 메모리에 존재한다는 것을 의미하기 때문이다.

   

4. 메소드 내에서 인스턴스 변수를 사용하지 않는다면 static을 붙이는 것을 고려한다.

    메소드의 작업 내용 중 인스턴스 변수를 필요로 하지 않는다면 static을 붙이자. 메소드 호출시간이 짧아지므로 성능이 향상된다. static을 안 붙인 메소드는 실행 시 호출되어야할 메소드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더 걸린다.

    각각의 클래스에 있는 static 메소드를 따로 모아서 모아두어도 된다.



```java
class MyMath2 {
	long a, b;
	
	long add() {
		return a + b;
	}
	long subtract() {
		return a - b;
	}
	long multiply() {
		return a * b;
	}
	long divide() {
		return a / b;
	}
	
	static long add(long a, long b) {
		return a + b;
	}
	static long subtract(long a, long b) {
		return a - b;
	}
	static long multiply(long a, long b) {
		return a * b;
	}
	static long divide(double a, double b) {
		return a / b;
	}
	
}

class MyMathTest2 {
	public static void main(String[] args) {
		System.out.println(MymathTest2.add(200L, 100L));
        System.out.println(MymathTest2.subtract(200L, 100L));
        System.out.println(MymathTest2.multiply(200L, 100L));
        System.out.println(MymathTest2.divide(200.0, 100.0));
        
        //---------------------------------------------------
        // 객체 생성 후에만 이용가능
        MyMath2 mm = new MyMath2();
        mm.a = 200L;
        mm.b = 100L;
        System.out.println(mm.add());
        System.out.println(mm.subtract());
        System.out.println(mm.multiply());
        System.out.println(mm.divide());
	}
}
```





## 3.12 클래스 멤버와 인스턴스 멤버간의 참조와 호출

 같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하다. 단, 클래스 멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 한다. **그 이유는 인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스 멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문이다.**



```java
class MemberCall {
	int iv = 10;
	static int cv = 20;
	
	int iv2 = cv;
	//static int cv2 = iv; //클래스 변수는 인스턴스 변수를 사용할 수 없음.
	static int cv2 = new MemberCall().iv; // 객체를 생성해야 사용 가능.
	
	static void staticMethod1() {
		System.out.println(cv);
		//System.out.println(iv); // 클래스 메소드에서 인스턴스 변수 사용 불가
		MemberCall c = new MemberCall();
		System.out.println(c.iv); // 객체 생성 후에 사용 가능
	}
	
	void instanceMethod1() {
		System.out.println(cv);
		System.out.println(iv);
	}
	
	static void staticMethod2() {
		staticMethod1();
		//instanceMethod1(); // 클래스 메소드에서 인스턴스 메소드 호출할 수 없음
		MemberCall c = new MemberCall();
		c.instanceMethod1(); // 인스턴스 생성 후에 사용 가능
	}
	
	void instanceMethod1() {
		staticMethod1();
		instanceMethod1();
	}
}
```



 클래스 변수, 메소드는 언제나 참조 또는 호출이 가능하기 때문에 인스턴스 변수, 메소드가 클래스 멤버를 사용하는 것은 아무런 문제가 안된다. 클래스 멤버 간의 참조 또는 호출 역시 문제가 없다.

 그러나 인스턴스 멤버는 반드시 객체를 생성한 후에 참조 또는 호출이 가능하기 때문에 클래스 멤버가 인스턴스 멤버를 참조, 호출하기 위해서는 객체를 생성한 후에 사용해야 한다. 인스턴스 멤버 간의 호출에는 아무런 문제가 없다. 

 실제로는 같은 클래스 내에서 클래스 멤버가 인스턴스 멤버를 참조 또는 호출해야하는 경우는 드물다. 만일 그런 경우가 있다면, 인스턴스 메소드로 작성해야할 메소드를 클래스 메소드로 작성한 것은 아닌지 한 번 더 고려해봐야 한다.